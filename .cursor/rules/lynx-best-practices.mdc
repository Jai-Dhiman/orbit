---
description: 
globs: 
alwaysApply: true
---
# Lynx Best Practices Guide

## React Lynx Fundamentals

### Import Differences

- Replace React imports with ReactLynx imports:
  ```diff
  - import { useState } from 'react';
  + import { useState } from '@lynx-js/react';
  ```
- ReactLynx implements the same API as React, allowing direct replacement

### Component Differences

- Use Lynx components instead of HTML elements:
  ```diff
  - <div className="container">
  -   <span>Hello World</span>
  - </div>
  + <view className="container">
  +   <text>Hello World</text>
  + </view>
  ```
- Core Lynx components:
  - `<view>` - Container element (similar to div)
  - `<text>` - Text display (similar to span/p)
  - `<image>` - Image display (similar to img)
  - `<page>` - Full-screen page container
  - `<scroll-view>` - Scrollable container

### Event Handling

- Lynx uses different event naming conventions:
  ```diff
  - <button onClick={handleClick} />
  + <view bindtap={handleTap} />
  ```
- Event propagation is different in Lynx:
  - Use `bindXXX` for normal event bubbling
  - Use `catchXXX` to stop event propagation (similar to stopPropagation)
- There is no direct equivalent to `e.preventDefault()`

### Platform Constraints

- No `document` or `window` objects in Lynx mobile
- Cannot use libraries that depend on browser DOM APIs
- Use Lynx-specific APIs instead:
  - `lynx.reload()` instead of `window.location.reload()`
- For unavailable features, use Lynx's NativeModules or Custom Elements

## Cross-Platform Development

### Project Setup

- **Monorepo Structure**: Maintain a single Lynx codebase that compiles to both web and mobile targets
- **Environmental Configuration**:
  ```typescript
  // lynx.config.ts
  import { defineConfig } from '@lynx-js/rspeedy';
  import { pluginReactLynx } from '@lynx-js/react-rsbuild-plugin';
  
  export default defineConfig({
    plugins: [pluginReactLynx()],
    environments: {
      web: {
        output: {
          assetPrefix: '/',
        },
      },
      lynx: {},
    },
  });
  ```

### Web Integration

- Use `<lynx-view>` custom element in web projects to render Lynx components
- Configure the web app to load the Lynx bundle from the build artifacts:
  ```tsx
  import './App.css';
  import '@lynx-js/web-core/index.css';
  import '@lynx-js/web-elements/index.css';
  import '@lynx-js/web-core';
  import '@lynx-js/web-elements/all';

  const App = () => {
    return (
      <lynx-view
        style={{ height: '100vh', width: '100vw' }}
        url="/main.web.bundle"
      ></lynx-view>
    );
  };
  ```
- Configure the Rsbuild project to serve Lynx artifacts:
  ```typescript
  // rsbuild.config.ts
  import { defineConfig } from '@rsbuild/core';
  import { pluginReact } from '@rsbuild/plugin-react';
  import path from 'node:path';
  import { fileURLToPath } from 'node:url';
  
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  
  export default defineConfig({
    plugins: [pluginReact()],
    server: {
      publicDir: [
        {
          name: path.join(
            __dirname,
            '../',
            'lynx-project', // Replace with your Lynx project path
            'dist',
          ),
        },
      ],
    },
  });
  ```

### Mobile Integration

- Use Lynx's native renderers for iOS and Android
- Leverage platform-specific APIs through Lynx's bridge mechanism
- Ensure proper handling of mobile-specific features (gestures, etc.)
- Test with Lynx Explorer App by scanning the QR code during development

## Component Design

### Platform-Agnostic Components

- Design UI components that work on both platforms without modification
- Use responsive layouts that adapt to different screen sizes and orientations
- Implement flexible styling that respects platform conventions
- Use Tailwind for consistent styling across platforms

### Platform-Specific Adaptations

- Use platform detection for conditional rendering:
  ```typescript
  const isWebPlatform = typeof window !== 'undefined' && typeof document !== 'undefined';
  
  // Platform-specific component rendering
  return isWebPlatform ? <WebComponent /> : <MobileComponent />;
  ```
- Create abstraction layers for platform-specific APIs
- Design responsive layouts that adapt to platform constraints

## State Management and Data Fetching

- Use Convex for backend state that's shared across platforms
- Implement platform-agnostic state management with Zustand
- Create platform-specific persistence strategies when needed
- For data fetching, use TanStack Query with platform-aware configurations

## Styling Best Practices

- Use Tailwind CSS for consistent styling across platforms
- Create platform-specific style variations when needed:
  ```typescript
  <view className={`base-styles ${isWebPlatform ? 'web-styles' : 'mobile-styles'}`}>
  ```
- Define responsive styles that work well on both platforms
- Avoid using styling approaches that are platform-specific (e.g., web-only CSS features)

## Build and Deployment

### Building for Web

- Run `npm run build` with web environment to create the web bundle
- Configure web host application to serve the Lynx bundle
- Optimize loading and performance for web browsers

### Building for Mobile

- Run `npm run build` with lynx environment to create mobile bundle
- Integrate with native mobile applications using Lynx's mobile SDKs
- Implement platform-specific optimizations

## Performance Optimization

- Minimize component re-renders
- Use the "background-only" pragma for heavy computations:
  ```typescript
  const onTap = useCallback(() => {
    "background-only"; // This computation will run in the background thread
    setAlterLogo(!alterLogo);
  }, [alterLogo]);
  ```
- Optimize image assets for each platform
- Leverage platform-specific optimizations where available

## Testing Strategy

- Test shared business logic with platform-agnostic tests
- Implement platform-specific tests for unique behavior
- Use visual testing to ensure consistent appearance across platforms
- Test responsive behavior for different screen sizes and orientations

## Development Workflow

1. Start with the Lynx development server:
   ```bash
   npm run dev
   ```
2. Scan QR code with Lynx Explorer App for mobile testing
3. Create a web host application for web testing
4. Develop core features in shared packages
5. Test on both platforms regularly during development
6. Address platform-specific issues with conditional code
7. Maintain a single source of truth for business logic

## Common Pitfalls and Solutions

- **DOM Dependency**: Avoid libraries that rely on browser DOM
- **Event Handling**: Remember Lynx uses different event naming (bindtap vs onClick)
- **Styling Differences**: Some CSS features work differently or not at all on mobile
- **Navigation**: Use appropriate navigation patterns for each platform
- **Form Inputs**: Form handling differs between web and mobile
- **Animations**: Use platform-appropriate animation techniques
