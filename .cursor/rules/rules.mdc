---
description: 
globs: 
alwaysApply: true
---
# Cursor Rules for Orbit Project frontend

## Monorepo Architecture

### Project and File Structure

- `/packages` - Shared code packages
  - `/core` - Shared business logic
    - `/api` - API abstractions and service functions
    - `/types` - Shared type definitions 
    - `/utils` - Utility functions used across platforms
    - `/hooks` - Shared custom hooks
    - `/state` - Cross-platform state management
  - `/ui` - Shared UI components
    - `/components` - Cross-platform UI components
    - `/styles` - Shared styles and themes
    - `/assets` - Shared images and icons

- `/apps` - Platform-specific applications
  - `/mobile` - Mobile application (Lynx)
    - `/src` - Mobile app source code
      - `/features` - Feature modules (vertical slicing)
        - `/notes` - Note-taking feature
          - `/components` - Feature-specific components
          - `/api` - Feature-specific API calls
          - `/hooks` - Feature-specific hooks
          - `/types` - Feature-specific types
          - `/utils` - Feature-specific utilities
          - `/stores` - Feature-specific state
          - `index.ts` - Public exports
        - `/calendar` - Calendar management
        - `/auth` - Authentication 
        - `/profile` - User profile
      - `/navigation` - Mobile-specific navigation
      - `/platform` - Mobile-specific implementations
      - `/shared` - App-level shared code
      - `/lib` - Third-party library wrappers
      - `/providers` - Context providers
      - `/config` - Configuration
      - `/assets` - Static assets
  - `/web` - Web application (Vite + React Router)
    - `/src` - Web app source code
      - `/features` - Feature modules (same structure as mobile)
      - `/routes` - Route components and definitions
        - `/index.tsx` - Root route component
        - `/_layout.tsx` - Layout wrapper for routes
        - `/auth/` - Auth-related routes
        - `/notes/` - Notes-related routes
      - `/components` - Shared web components
      - `/hooks` - Web-specific hooks
      - `/utils` - Web-specific utilities
      - `/constants` - App constants
      - `/assets` - Static assets
      - `/styles` - Global styles
      - `main.tsx` - Application entry point
      - `App.tsx` - Main App component with routing setup
      - `vite-env.d.ts` - Vite type declarations
  - `/server` - Shared backend
    - `/convex` - Convex backend code
      - `/schema` - Database schema
      - `/functions` - Server functions
      - `/auth` - Authentication logic

### Platform Integration Strategy

- **Code Sharing:**
  - Core business logic, API calls, and utilities in `/packages/core`
  - Shared UI components in `/packages/ui`
  - Platform-specific code in respective app directories

- **Web Architecture (Vite + React Router):**
  - Client-side rendering (CSR) approach for authenticated app experience
  - React Router for navigation and route management
  - Vite for fast development and optimized builds
  - Integration with shared core packages

- **Mobile Architecture (Lynx):**
  - Lynx Framework for native-like mobile experience
  - Platform-specific UI implementations
  - Shared business logic from core packages

- **Backend Integration:**
  - Convex backend shared between web and mobile
  - Use same API abstractions from core package
  - TanStack Query for data fetching in both platforms

### Naming Conventions

- Components: PascalCase (e.g., `CalendarWidget.tsx`)
- Hooks: camelCase with 'use' prefix (e.g., `useNotifications.ts`)
- Utilities: camelCase (e.g., `formatDateTime.ts`)
- Store files: camelCase with 'store' suffix (e.g., `notificationStore.ts`)
- Query files: camelCase with 'queries' suffix (e.g., `calendarQueries.ts`)
- Route files: kebab-case (e.g., `user-profile.tsx`) or descriptive names in directories

## Package Management with Bun

- Use Bun as the preferred package manager
- Run `bun install` to install dependencies
- Manage scripts via `bun run [script]` as defined in package.json
- Use `bun.lockb` for deterministic builds
- Leverage Bun's built-in TypeScript support and bundling capabilities
- When adding new dependencies, use `bun add [package]` (or `bun add -d [package]` for dev dependencies)
- For global installations, use `bun add -g [package]`

## Vite Configuration

- Use `vite.config.ts` for Vite-specific configurations
- Configure path aliases to match monorepo structure
- Set up environment variables with `.env` files
- Configure build optimizations for production
- Use Vite plugins as needed (e.g., `@vitejs/plugin-react`)

## React Router Configuration

- Use React Router v6+ with data loading APIs
- Implement route-based code splitting for performance
- Structure routes hierarchically with nested layouts
- Use route loaders for data fetching when appropriate
- Implement type-safe routing with proper typing

## Styling with Tailwind CSS and Shadcn UI

### Tailwind CSS

- Use Tailwind utility classes for styling components
- Follow mobile-first approach for responsive design
- Use `clsx` or `cn` utility for conditional class names
- Extract common utility patterns to components instead of using `@apply`
- Configure theme tokens in `tailwind.config.js`
- Use CSS variables for dynamic theming

### Shadcn UI

- Import components selectively to minimize bundle size
- Customize appearance through the Tailwind theme configuration
- Use the components as a foundation, extending them when needed
- Maintain accessibility standards when customizing components
- Leverage component variants for consistent styling

## Testing with Vitest

### Setup

- All tests should be located next to the files they test with `.test.ts` or `.test.tsx` extension
- Use the React Testing Library with Vitest for component testing
- Configure test environment in `vitest.config.ts`

### Test Structure

- Group related tests with descriptive `describe` blocks
- Use clear, action-oriented test names with `it` or `test`
- Follow the AAA pattern: Arrange, Act, Assert
- Test components in isolation with appropriate mocks

### Best Practices

- Focus on testing behavior, not implementation details
- Use `screen` queries and user-event for interaction testing
- Write tests that resemble how users interact with your app
- Implement proper cleanup between tests

### Component Testing

- Test different component states (loading, error, success)
- Verify proper rendering of UI elements
- Test interactions and state changes
- Validate accessibility concerns

## State Management with Zustand

### Store Structure

- Create separate stores for different features (vertical slicing)
- Keep state minimal and normalized
- Define actions within the store
- Implement proper TypeScript typing for stores

### Usage Patterns

- Use selectors to access specific state slices
- Avoid unnecessary re-renders by selecting only needed data
- Implement middleware for side effects or persistence
- Store only client state in Zustand; server state should be in TanStack Query

## TanStack Query Best Practices

### Setup and Configuration

- Define a central queryClient with appropriate defaults for all applications
- Use proper staleTime and cacheTime settings based on data volatility
- Implement global error handling in queryClient configuration
- Configure retries appropriately based on API reliability

### Query Structure

- Create custom hooks for each query to encapsulate query logic
- Use prefetching for anticipated data needs
- Implement appropriate query keys with proper structure (array format)
- Enable suspense mode for React 18+ applications

### Data Management

- Implement optimistic updates for mutations when appropriate
- Use query invalidation strategically to maintain data freshness
- Leverage onSuccess/onError callbacks for side effects
- Implement appropriate pagination or infinite scroll techniques

### Performance Optimization

- Select only the data you need from query results
- Use enabled option to conditionally execute queries
- Implement proper query key factories for parameterized queries
- Set up proper query deduplication

### Usage Patterns

- Separate server state (TanStack Query) from client state (Zustand)
- Implement proper loading and error states for all queries
- Use placeholderData or initialData for improved UX
- Leverage query cancellation for abandoned requests

## TanStack Form Best Practices

### Form Setup

- Create reusable form configurations with consistent validation
- Leverage schema-based validation (Zod) integrated with TanStack Form
- Implement proper TypeScript types for form values and errors
- Use fieldArrays for dynamic form sections

### Error Handling

- Implement field-level, form-level, and submission error handling
- Display errors in accessible, user-friendly ways
- Provide clear error messages with resolution guidance
- Implement proper focus management for invalid fields

### Performance

- Use controlled components sparingly to minimize re-renders
- Implement efficient validation strategies (validateOnBlur vs validateOnChange)
- Leverage shouldUseNativeValidation where appropriate
- Use fieldState effectively to optimize render performance

### User Experience

- Implement proper loading states during form submission
- Use proper disabled states for fields during processing
- Maintain form state during navigation when appropriate
- Provide clear success/error feedback after submission
